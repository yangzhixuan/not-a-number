// Generated by CoffeeScript 1.4.0
(function() {

  this.hsvString = function(h, s, v) {
    var color;
    color = hsvToRgb(h, s, v);
    return colorToString([Math.floor(color[0]), Math.floor(color[1]), Math.floor(color[2])]);
  };

  this.randomColor = function() {
    var color;
    color = hsvToRgb(Math.random() * 0.1 + 0.4, 0.8, 0.9);
    return [Math.floor(color[0]), Math.floor(color[1]), Math.floor(color[2])];
  };

  this.colorToString = function(color) {
    return "rgb(" + color[0] + ", " + color[1] + ", " + color[2] + ")";
  };

  this.randomColorString = function() {
    var color;
    color = randomColor();
    return colorToString(color);
  };

  this.clamp = function(a) {
    return Math.max(Math.min(a, 1.0), 0.0);
  };

  this.mediate = function(left, right, rate) {
    return left + (right - left) * rate;
  };

  this.colorToString = function(color) {
    return "hsla(" + ((color.h - Math.floor(color.h)) * 360) + ", " + (clamp(color.s) * 100) + "%, " + (clamp(color.l) * 100) + "%, 1.0)";
  };

  NAN.Game = (function() {

    function Game() {
      var i, _i, _ref;
      $.backgroundBlockId = 0;
      this.background = new NAN.Background;
      this.score = new NAN.Score;
      this.gridId = 0;
      this.init();
      this.gridMargin = 4;
      this.containerHeight = 680;
      this.containerWidth = 680;
      this.numGridRows = 6;
      this.numGridColumns = 6;
      this.numGrids = this.numGridColumns * this.numGridRows;
      this.gridWidth = (this.containerWidth - 100) / this.numGridRows;
      this.gridHeight = this.gridWidth;
      this.gridXOffset = 90;
      this.gridYOffset = (this.containerWidth - this.numGridColumns * this.gridWidth) / 2;
      console.log(this.gridWidth);
      setStyleRuleValue(".board", "width", "" + this.containerWidth + "px");
      setStyleRuleValue(".board", "height", "" + this.containerHeight + "px");
      setStyleRuleValue(".number", "line-height", "" + this.gridHeight + "px");
      setStyleRuleValue(".square", "height", "" + (this.gridHeight - this.gridMargin * 2) + "px");
      setStyleRuleValue(".square", "width", "" + (this.gridWidth - this.gridMargin * 2) + "px");
      this.grids = [];
      this.mouse = new NAN.Mouse;
      this.paused = true;
      this.timeLeft = 100;
      this.gridQueue = [];
      for (i = _i = 0, _ref = this.numGridRows; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.grids[i] = [];
      }
    }

    Game.prototype.newGrid = function(x, y) {
      var grid;
      grid = new NAN.Grid(x, y, this);
      this.grids[x][y] = grid;
      grid.init();
      return this.gridQueue.push(grid);
    };

    Game.prototype.init = function() {
      return this.time = 0;
    };

    Game.prototype.movementEnd = function() {
      var grid, result, row, _i, _j, _len, _len1, _ref;
      result = true;
      _ref = this.grids;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
          grid = row[_j];
          if (grid !== null && grid.deltaX !== 0) {
            result = false;
          }
        }
      }
      return result;
    };

    Game.prototype.nextFrame = function() {
      var x, y, _i, _j, _len, _ref, _ref1, _results, _results1;
      _ref1 = (function() {
        _results1 = [];
        for (var _j = 0, _ref = this.numGridRows; 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).reverse();
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        _results.push((function() {
          var _k, _ref2, _results2;
          _results2 = [];
          for (y = _k = 0, _ref2 = this.numGridColumns; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; y = 0 <= _ref2 ? ++_k : --_k) {
            if (this.grids[x][y] === null || !this.grids[x][y].exist) {
              if (x > 0 && this.grids[x - 1][y] !== null) {
                this.grids[x - 1][y].deltaX += this.gridHeight;
                this.grids[x][y] = this.grids[x - 1][y];
                this.grids[x - 1][y].moveTo(x, y);
                _results2.push(this.grids[x - 1][y] = null);
              } else if (x === 0) {
                _results2.push(this.newGrid(x, y));
              } else {
                _results2.push(void 0);
              }
            } else {
              _results2.push(void 0);
            }
          }
          return _results2;
        }).call(this));
      }
      return _results;
    };

    Game.prototype.updateGrids = function() {
      var grid, newQueue, _i, _len, _ref;
      newQueue = [];
      _ref = this.gridQueue;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        grid = _ref[_i];
        if (grid === null || grid.exist === false) {
          0;

        } else {
          grid.update();
          newQueue.push(grid);
        }
      }
      return this.gridQueue = newQueue;
    };

    Game.prototype.getPaused = function() {
      if (this.time <= 100) {
        return true;
      }
      if ($.numberShow && !$.numberShow.finished) {
        return true;
      }
      if (!this.movementEnd()) {
        return true;
      }
      return false;
    };

    Game.prototype.update = function() {
      var x, y, _i, _ref;
      this.paused = this.getPaused();
      if (this.time < this.numGridRows) {
        x = this.time;
        for (y = _i = 0, _ref = this.numGridColumns; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
          this.newGrid(x, y);
          /*
                          grid.getElement().mouseover( ->
                              $(this).hide(400, ->
                                  $(this).show(300)
                              )
                          )
          */

        }
      } else {
        this.nextFrame();
      }
      this.updateGrids();
      this.score.update();
      this.background.update();
      this.time += 1;
      if ($.numberShow) {
        $.numberShow.update();
        if ($.numberShow.finished) {
          $.numberShow = null;
        }
      }
      if (!this.paused) {
        this.timeLeft -= 0.03;
      }
      return $("#progressbar").attr("value", "" + this.timeLeft);
    };

    return Game;

  })();

  $(document).ready(function() {
    var timeStep;
    timeStep = 0;
    $("#number-show").hide();
    $("#number-show").css("opacity", "0.0");
    $.analyzer = new window.NAN.Analyzer;
    $("#title").animate({
      top: "-=400px"
    }, 0);
    $("#title").animate({
      top: "+=400px"
    }, 1900 * timeStep);
    $("#how-to-play").slideUp(0);
    $("#container").animate({
      top: "+=700px"
    }, 0);
    $("#container").animate({
      top: "-=700px"
    }, 1900 * timeStep);
    $.game = new NAN.Game;
    setTimeout(function() {
      return setInterval(function() {
        return $.game.update();
      }, 20);
    }, 2000 * timeStep);
    setTimeout(function() {
      $("#title-1").animate({
        fontSize: "90px"
      }, 500 * timeStep);
      $("#title-2").slideUp(500 * timeStep);
      return $("#title-3").animate({
        fontSize: "49px"
      }, 500 * timeStep);
    }, 3000 * timeStep);
    $("body").mouseup(function() {
      return $.game.mouse.endPath();
    });
    return setTimeout(function() {
      return $("#how-to-play").slideDown(700);
    }, 4000 * timeStep);
  });

}).call(this);
