// Generated by CoffeeScript 1.4.0
(function() {

  NAN.Game = (function() {

    function Game() {
      var i, _i, _ref;
      $.backgroundBlockId = 0;
      this.score = new NAN.Score;
      this.gridId = 0;
      this.init();
      this.gridMargin = 2;
      this.containerHeight = 670;
      this.containerWidth = 600;
      this.numGridRows = 6;
      this.numGridColumns = 6;
      this.numGrids = this.numGridColumns * this.numGridRows;
      this.gridWidth = (this.containerWidth - 100) / this.numGridRows;
      this.gridHeight = this.gridWidth;
      this.gridXOffset = 110;
      this.gridYOffset = (this.containerWidth - this.numGridColumns * this.gridWidth) / 2;
      console.log(this.gridWidth);
      setStyleRuleValue(".board", "width", "" + this.containerWidth + "px");
      setStyleRuleValue(".board", "height", "" + this.containerHeight + "px");
      setStyleRuleValue(".number", "line-height", "" + this.gridHeight + "px");
      setStyleRuleValue(".square", "height", "" + (this.gridHeight - this.gridMargin * 2) + "px");
      setStyleRuleValue(".square", "width", "" + (this.gridWidth - this.gridMargin * 2) + "px");
      this.grids = [];
      this.mouse = new NAN.Mouse;
      this.paused = true;
      this.timeLeft = 100;
      this.gridQueue = [];
      for (i = _i = 0, _ref = this.numGridRows; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.grids[i] = [];
      }
      this.initTouchScreen();
    }

    Game.prototype.initTouchScreen = function() {
      var _this = this;
      $("#container").on("touchstart", function(e) {
        var grid;
        grid = _this.getEventGrid(e);
        if (grid) {
          grid.mouseDown();
        }
        return false;
      });
      $("#container").on("touchmove", function(e) {
        var grid;
        grid = _this.getEventGrid(e);
        if (grid) {
          grid.mouseOver();
        }
        console.log(grid);
        return false;
      });
      return $("#container").on("touchend", function(e) {
        _this.mouse.endPath();
        return false;
      });
    };

    Game.prototype.getEventPosition = function(e) {
      var x, y;
      y = e.originalEvent.targetTouches[0].pageX - $("#container").offset().left;
      x = e.originalEvent.targetTouches[0].pageY - $("#container").offset().top;
      return {
        x: x,
        y: y
      };
    };

    Game.prototype.getEventGrid = function(e) {
      var pos;
      pos = this.getEventPosition(e);
      return this.getGridAt(pos.x, pos.y);
    };

    Game.prototype.newGrid = function(x, y) {
      var grid;
      grid = new NAN.Grid(x, y, this);
      this.grids[x][y] = grid;
      grid.init();
      return this.gridQueue.push(grid);
    };

    Game.prototype.getGridAt = function(x, y) {
      var grid, _i, _len, _ref;
      _ref = this.gridQueue;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        grid = _ref[_i];
        if (grid.testInside(x, y)) {
          return grid;
        }
      }
      return null;
    };

    Game.prototype.init = function() {
      return this.time = 0;
    };

    Game.prototype.movementEnd = function() {
      var grid, result, row, _i, _j, _len, _len1, _ref;
      result = true;
      _ref = this.grids;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
          grid = row[_j];
          if (grid !== null && grid.deltaX !== 0) {
            result = false;
          }
        }
      }
      return result;
    };

    Game.prototype.nextFrame = function() {
      var x, y, _i, _j, _len, _ref, _ref1, _results, _results1;
      _ref1 = (function() {
        _results1 = [];
        for (var _j = 0, _ref = this.numGridRows; 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).reverse();
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        _results.push((function() {
          var _k, _ref2, _results2;
          _results2 = [];
          for (y = _k = 0, _ref2 = this.numGridColumns; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; y = 0 <= _ref2 ? ++_k : --_k) {
            if (this.grids[x][y] === null || !this.grids[x][y].exist) {
              if (x > 0 && this.grids[x - 1][y] !== null) {
                this.grids[x - 1][y].deltaX += this.gridHeight;
                this.grids[x][y] = this.grids[x - 1][y];
                this.grids[x - 1][y].moveTo(x, y);
                _results2.push(this.grids[x - 1][y] = null);
              } else if (x === 0) {
                _results2.push(this.newGrid(x, y));
              } else {
                _results2.push(void 0);
              }
            } else {
              _results2.push(void 0);
            }
          }
          return _results2;
        }).call(this));
      }
      return _results;
    };

    Game.prototype.updateGrids = function() {
      var grid, newQueue, _i, _len, _ref;
      newQueue = [];
      _ref = this.gridQueue;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        grid = _ref[_i];
        if (grid === null || grid.exist === false) {
          0;

        } else {
          grid.update();
          newQueue.push(grid);
        }
      }
      return this.gridQueue = newQueue;
    };

    Game.prototype.getPaused = function() {
      if (this.time <= 100) {
        return true;
      }
      if ($.numberShow && !$.numberShow.finished) {
        return true;
      }
      if (!this.movementEnd()) {
        return true;
      }
      return false;
    };

    Game.prototype.update = function() {
      var x, y, _i, _ref;
      this.paused = this.getPaused();
      if (this.time < this.numGridRows * 10) {
        if (this.time % 10 === 0) {
          x = this.time / 10;
          for (y = _i = 0, _ref = this.numGridColumns; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
            this.newGrid(x, y);
          }
        }
      } else {
        this.nextFrame();
      }
      this.updateGrids();
      this.score.update();
      this.time += 1;
      if ($.numberShow) {
        $.numberShow.update();
        if ($.numberShow.finished) {
          $.numberShow = null;
        }
      }
      if (!this.paused) {
        this.timeLeft -= 0.03;
      }
      return $("#progressbar").attr("value", "" + this.timeLeft);
    };

    return Game;

  })();

  $(document).ready(function() {
    var timeStep;
    timeStep = 1.5;
    $("#number-show").hide();
    $("#number-show").css("opacity", "0.0");
    $.analyzer = new window.NAN.Analyzer;
    $("#title").animate({
      top: "-=400px"
    }, 0);
    $("#title").animate({
      top: "+=400px"
    }, 1900 * timeStep);
    $("#how-to-play").slideUp(0);
    $("#container").animate({
      top: "+=700px"
    }, 0);
    $("#container").animate({
      top: "-=700px"
    }, 1900 * timeStep);
    $.game = new NAN.Game;
    setTimeout(function() {
      return setInterval(function() {
        return $.game.update();
      }, 20);
    }, 2000 * timeStep);
    setTimeout(function() {
      $("#title-1").animate({
        fontSize: "90px"
      }, 500 * timeStep);
      $("#title-2").slideUp(500 * timeStep);
      return $("#title-3").animate({
        fontSize: "49px"
      }, 500 * timeStep);
    }, 3000 * timeStep);
    $("body").mouseup(function() {
      return $.game.mouse.endPath();
    });
    return setTimeout(function() {
      return $("#how-to-play").slideDown(700);
    }, 4000 * timeStep);
  });

}).call(this);
